generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
}

/* -----------------------------------
   ENUMS
------------------------------------ */

enum Role {
  USER
  TEACHER   // optional, but not required for platform logic
  ADMIN
}

enum CourseVisibility {
  DRAFT
  PUBLISHED
  UNLISTED
  ARCHIVED
}

enum ContentStatus {
  PROCESSING
  READY
  FAILED
}

enum ContentType {
  VIDEO
  AUDIO
  PDF
}

enum CertificateTargetType {
  COURSE
  CONTENT
  USER
  GENERIC
}

enum CompletionStatus {
  IN_PROGRESS
  COMPLETED
}

enum NftPolicyMode {
  PLATFORM_MANAGED
  CREATOR_MANAGED
}

enum NftClaimStatus {
  LOCKED
  PAYMENT_PENDING
  PAID
  MINTING
  MINTED
  FAILED
}

/* -----------------------------------
   USER / AUTH
------------------------------------ */

model User {
  id              String      @id @default(uuid())
  name            String?
  email           String      @unique
  image           String?
  password        String?
  walletAddress   String?     @db.Text
  hasOnboarded    Boolean     @default(false)
  emailVerified   DateTime?
  role            Role        @default(USER)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  accounts        Account[]
  sessions        Session[]

  // content ownership
  contents        Content[]

  // course ownership
  courses         Course[] @relation("AuthorCourses")

  // enrollments
  enrollments     Enrollment[]
  // referral tracking
  shareStats      CourseShareStats[]   @relation("InstructorShareStats")
  shareClicks     CourseShareClick[]   @relation("InstructorShareClicks")
  courseStudentRefs CourseStudents[]   @relation("RefInstructorUsers")
  courseStudentMemberships CourseStudents[] @relation("CourseStudentUsers")
  classrooms    Classroom[]  @relation("UserClassrooms")
  // social
  followers       Follow[] @relation("following")
  following       Follow[] @relation("follower")

  // engagement
  contentLikes    ContentLike[]
  contentReviews  ContentReview[]
  // Watch-time tracking per course
  courseWatchProgress CourseWatchProgress[]
  // certificate relations
  issuedCertificates     CertificateNFT[] @relation("IssuedCertificates")
  receivedCertificates   CertificateNFT[] @relation("ReceivedCertificates")

  // peer ratings
  givenUserRatings       UserRating[] @relation("UserGivenRatings")
  receivedUserRatings    UserRating[] @relation("UserReceivedRatings")
  taughtEscrows          Escrow[] @relation("EscrowTeacher")
  studentEscrows         Escrow[] @relation("EscrowStudent")
  nftMintClaims          NftMintClaim[] @relation("UserNftClaims")
  courseCompletions      CourseCompletion[]
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user         User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

/* -----------------------------------
   COURSES
------------------------------------ */

model Course {
  id              String             @id @default(uuid())
  userId          String
  title           String
  description     String?
  coverImage      String?
  language        String?
  slug            String             @unique

  // metadata / pricing
  priceAda        Decimal?
  isPaid          Boolean            @default(false)
  visibility      CourseVisibility   @default(DRAFT)

  // analytics + cached values
  totalDuration   Int?
  totalParts      Int?
  averageRating   Float?
  ratingCount     Int?
  enrollmentCount Int?               @default(0)

  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt

  author          User               @relation("AuthorCourses", fields: [userId], references: [id], onDelete: Cascade)
  contents        Content[]
  enrollments     Enrollment[]
  shareStats      CourseShareStats[]   @relation("CourseShareStatsCourse")
  shareClicks     CourseShareClick[]   @relation("CourseShareClickCourse")
  courseStudents  CourseStudents[]     @relation("CourseStudentCourse")
  certificates    CertificateNFT[]
  escrowLinks     Escrow[]           @relation("CourseEscrows")
  nftConfig       CourseNftConfig?
  nftClaims       NftMintClaim[]     @relation("CourseNftClaims")
  completions     CourseCompletion[]
  // Watch-time aggregation per course
  courseWatchProgress CourseWatchProgress[]
  @@index([userId])
}

/* -----------------------------------
   CourseWatchProgress
------------------------------------ */

model CourseWatchProgress {
  userId         String
  courseId       String
  watchedSeconds Int      @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)

  // Composite primary key:
  // - guarantees one progress row per user per course
  // - enables atomic upserts
  @@id([userId, courseId])

  @@index([courseId])
  @@index([userId])
}


/* -----------------------------------
   CONTENT
------------------------------------ */

model Content {
  id            String        @id @default(uuid())
  userId        String
  courseId      String?
  classroomId   String?       // legacy support

  title         String
  description   String?
  type          ContentType
  url           String?

  partNumber    Int?
  accessLevel   String?
  status        ContentStatus @default(PROCESSING)

  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  author        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  course        Course?       @relation(fields: [courseId], references: [id], onDelete: Cascade)

  classroom     Classroom?    @relation(fields: [classroomId], references: [id])

  contentReviews ContentReview[]
  certificates  CertificateNFT[]  @relation("ContentCertificates")
  likes          ContentLike[]
  mediaMetadata  MediaMetadata?

  muxAssetId     String?      @unique
  muxPlaybackId  String?      @unique
  muxUploadId    String?      @unique

  @@index([courseId])
  @@index([userId])
  @@unique([courseId, partNumber], name: "course_part_unique")
}

/* -----------------------------------
   LEGACY CLASSROOM (DO NOT DELETE)
------------------------------------ */

model Classroom {
  id          String     @id @default(uuid())
  userId      String
  name        String?
  description String?
  image       String?
  slug        String?    @unique

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  author      User @relation(fields: [userId], references: [id], name: "UserClassrooms")
  
  contents    Content[]
  students    Enrollment[]
}

/* -----------------------------------
   ENGAGEMENT
------------------------------------ */

model ContentReview {
  id          String   @id @default(uuid())
  userId      String
  contentId   String
  rating      Int
  comment     String?
  createdAt   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  content     Content  @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@unique([userId, contentId])
}

model ContentLike {
  id        String   @id @default(uuid())
  userId    String
  contentId String
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  content   Content  @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@unique([userId, contentId])
}

model Follow {
  id           String   @id @default(uuid())
  followerId   String
  followingId  String
  createdAt    DateTime @default(now())

  follower     User @relation("follower", fields: [followerId], references: [id], onDelete: Cascade)
  following    User @relation("following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
}

/* -----------------------------------
   PEER RATING (ANYONE CAN RATE ANYONE)
------------------------------------ */

model UserRating {
  id         String   @id @default(uuid())
  raterId    String
  ratedId    String
  rating     Int
  comment    String?
  createdAt  DateTime @default(now())

  rater      User @relation("UserGivenRatings", fields: [raterId], references: [id], onDelete: Cascade)
  rated      User @relation("UserReceivedRatings", fields: [ratedId], references: [id], onDelete: Cascade)

  @@unique([raterId, ratedId])
  @@index([ratedId])
}

/* -----------------------------------
   CERTIFICATES (ANYONE â†’ ANYONE)
------------------------------------ */

model CertificateNFT {
  id            String   @id @default(uuid())
  tokenId       String   @unique
  metadataCid   String?
  issuedAt      DateTime @default(now())

  issuerId      String
  recipientId   String

  issuer        User @relation("IssuedCertificates", fields: [issuerId], references: [id], onDelete: Cascade)
  recipient     User @relation("ReceivedCertificates", fields: [recipientId], references: [id], onDelete: Cascade)

  targetType    CertificateTargetType
  courseId      String?
  contentId     String?
  label         String?
  credibilityScore Float? @default(0)

  course        Course?  @relation(fields: [courseId], references: [id], onDelete: SetNull)
  content       Content? @relation(fields: [contentId], references: [id], name: "ContentCertificates", onDelete: SetNull)

  @@index([issuerId])
  @@index([recipientId])
  @@index([courseId])
  @@index([contentId])
}

model CourseNftConfig {
  id               String         @id @default(uuid())
  courseId         String         @unique
  enabled          Boolean        @default(false)
  fineLovelace     BigInt         @default(0)
  eligibilityRule  String         @default("WATCH_100")
  metadataTemplate Json?
  imageUrl         String?
  policyMode       NftPolicyMode  @default(PLATFORM_MANAGED)
  policyId         String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  course           Course         @relation(fields: [courseId], references: [id], onDelete: Cascade)
}

model NftMintClaim {
  id                   String         @id @default(uuid())
  courseId             String
  userId               String
  recipientAddress     String
  payerAddress         String
  status               NftClaimStatus @default(LOCKED)
  fineLovelace         BigInt         @default(0)
  estimatedFeeLovelace BigInt         @default(0)
  txHash               String?
  policyId             String?
  assetName            String?
  assetId              String?
  errorCode            String?
  errorMessage         String?
  idempotencyKey       String         @default(uuid())
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt

  course               Course         @relation("CourseNftClaims", fields: [courseId], references: [id], onDelete: Cascade)
  user                 User           @relation("UserNftClaims", fields: [userId], references: [id], onDelete: Cascade)

  @@index([courseId])
  @@index([userId])
  @@index([status])
  @@unique([courseId, userId, idempotencyKey])
}

model CourseCompletion {
  id          String            @id @default(uuid())
  courseId    String
  userId      String
  status      CompletionStatus  @default(IN_PROGRESS)
  completedAt DateTime?
  proof       Json?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  course      Course            @relation(fields: [courseId], references: [id], onDelete: Cascade)
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([courseId, userId])
  @@index([courseId])
  @@index([userId])
}

/* -----------------------------------
   MEDIA METADATA
------------------------------------ */

model MediaMetadata {
  id        String   @id @default(uuid())
  contentId String   @unique
  duration  Int
  size      Int
  format    String

  content   Content  @relation(fields: [contentId], references: [id], onDelete: Cascade)
}

/* -----------------------------------
   ENROLLMENTS
------------------------------------ */

model Enrollment {
  id          String   @id @default(uuid())
  userId      String
  classroomId String?     // legacy
  courseId    String?
  joinedAt    DateTime @default(now())

  student     User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  classroom   Classroom?  @relation(fields: [classroomId], references: [id])
  course      Course?     @relation(fields: [courseId], references: [id])

  @@index([courseId])
  @@index([userId])
}

/* -----------------------------------
   REFERRAL / SHARE TRACKING
------------------------------------ */

model CourseShareStats {
  id               String   @id @default(uuid())
  courseId         String
  instructorId     String
  totalClicks      Int      @default(0)
  totalEnrollments Int      @default(0)
  conversionRate   Float    @default(0)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  course      Course @relation("CourseShareStatsCourse", fields: [courseId], references: [id], onDelete: Cascade)
  instructor  User   @relation("InstructorShareStats", fields: [instructorId], references: [id], onDelete: Cascade)

  @@unique([courseId, instructorId])
  @@index([instructorId])
}

model CourseShareClick {
  id           String   @id @default(uuid())
  courseId     String
  instructorId String
  ipHash       String?
  userAgent    String?
  createdAt    DateTime @default(now())

  course     Course @relation("CourseShareClickCourse", fields: [courseId], references: [id], onDelete: Cascade)
  instructor User   @relation("InstructorShareClicks", fields: [instructorId], references: [id], onDelete: Cascade)

  @@index([courseId, instructorId, createdAt])
  @@index([courseId, instructorId, ipHash])
}

model CourseStudents {
  id              String   @id @default(uuid())
  courseId        String
  studentId       String
  refInstructorId String
  createdAt       DateTime @default(now())

  course        Course @relation("CourseStudentCourse", fields: [courseId], references: [id], onDelete: Cascade)
  student       User   @relation("CourseStudentUsers", fields: [studentId], references: [id], onDelete: Cascade)
  refInstructor User   @relation("RefInstructorUsers", fields: [refInstructorId], references: [id], onDelete: Cascade)

  @@unique([courseId, studentId])
  @@index([refInstructorId])
  @@index([courseId])
}

/* -----------------------------------
   ESCROW (Cardano Payments)
------------------------------------ */

model Escrow {
  id             String    @id @default(uuid())
  courseId       String?
  teacherId      String?
  studentId      String?
  adaAmount      Decimal   @default(0)
  status         String    @default("PENDING")
  lockedAt       DateTime  @default(now())
  receiverPkh    String?
  oraclePkh      String?
  scriptAddress  String?
  netTotal       Decimal   @default(0)
  paidCount      Int       @default(0)
  paidOut        Decimal   @default(0)
  released30     Boolean   @default(false)
  released40     Boolean   @default(false)
  releasedFinal  Boolean   @default(false)
  comments       Int       @default(0)
  ratingSum      Int       @default(0)
  ratingCount    Int       @default(0)
  allWatchMet    Boolean   @default(true)
  firstWatch     BigInt    @default(0)
  disputeBy      BigInt    @default(0)

  course        Course? @relation("CourseEscrows", fields: [courseId], references: [id], onDelete: SetNull)
  teacher       User?   @relation("EscrowTeacher", fields: [teacherId], references: [id], onDelete: Cascade)
  student       User?   @relation("EscrowStudent", fields: [studentId], references: [id], onDelete: Cascade)

  @@index([courseId])
  @@index([teacherId])
  @@index([studentId])
}
